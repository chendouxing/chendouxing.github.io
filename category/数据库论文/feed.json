{
    "version": "https://jsonfeed.org/version/1",
    "title": "蟹堡王海星 • All posts by \"数据库论文\" category",
    "description": "花有重开日，人无再少年",
    "home_page_url": "https://chendouxing.github.io",
    "items": [
        {
            "id": "https://chendouxing.github.io/2023/09/06/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/",
            "url": "https://chendouxing.github.io/2023/09/06/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/",
            "title": "分布式论文阅读",
            "date_published": "2023-09-06T06:38:56.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h1 id=\"分布式理论\"><a class=\"markdownIt-Anchor\" href=\"#分布式理论\">#</a> 分布式理论</h1>\n<h2 id=\"cap理论\"><a class=\"markdownIt-Anchor\" href=\"#cap理论\">#</a> CAP 理论</h2>\n<h3 id=\"理论概述\"><a class=\"markdownIt-Anchor\" href=\"#理论概述\">#</a> 理论概述</h3>\n<p><strong>一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项</strong>。</p>\n<h3 id=\"一致性\"><a class=\"markdownIt-Anchor\" href=\"#一致性\">#</a> 一致性</h3>\n<ul>\n<li>\n<p>对于一致性，可以分为从客户端和服务端两个不同的视角。</p>\n<p>客户端：从客户端来看，一致性主要指的是多并发访问时更新过的数据如何获取的问题。</p>\n<p>服务端：从服务端来看，则是更新如何分布到整个系统，以保证数据最终一致。</p>\n</li>\n<li>\n<p>对于一致性，可以分为强 / 弱 / 最终一致性三类</p>\n<p>从客户端角度，多进程并发访问时，更新过的数据在不同进程如何获取的不同策略，决定了不同的一致性。</p>\n</li>\n</ul>\n<ol>\n<li>强一致性：对于关系型数据库，要求更新过的数据能被后续的访问都能看到，这是强一致性。</li>\n<li>弱一致性：如果能容忍后续的部分或者全部访问不到，则是弱一致性。</li>\n<li>最终一致性：如果经过一段时间后要求能访问到更新后的数据，则是最终一致性。</li>\n</ol>\n<h3 id=\"可用性\"><a class=\"markdownIt-Anchor\" href=\"#可用性\">#</a> 可用性</h3>\n<p>可用性指服务在正常响应时间内一直可用。</p>\n<p>好的可用性主要是指系统能够很好的为用户服务，不出现用户操作失败或者访问超时等用户体验不好的情况。可用性通常情况下与分布式数据冗余，负载均衡等有着很大的关联。</p>\n<h3 id=\"分区容错性\"><a class=\"markdownIt-Anchor\" href=\"#分区容错性\">#</a> 分区容错性</h3>\n<p>分区容错性指分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性或可用性的服务。</p>\n<hr>\n<h2 id=\"base模型\"><a class=\"markdownIt-Anchor\" href=\"#base模型\">#</a> BASE 模型</h2>\n<h3 id=\"理论概述-2\"><a class=\"markdownIt-Anchor\" href=\"#理论概述-2\">#</a> 理论概述</h3>\n<p>Base 理论是三要素的缩写：基本可用（Basically Available）、软状态（Soft-state）、最终一致性（Eventually Consistency）。</p>\n<h3 id=\"基本可用\"><a class=\"markdownIt-Anchor\" href=\"#基本可用\">#</a> 基本可用</h3>\n<p>“基本可用” 要求系统能够基本运行，一直提供服务，强调的是分布式系统在出现不可预知故障的时候，允许损失部分可用性。</p>\n<h3 id=\"软状态\"><a class=\"markdownIt-Anchor\" href=\"#软状态\">#</a> 软状态</h3>\n<p>相对于 ACID 事务中原子性要求（要么做，要么不做），强调的是强制一致性，要求多个节点的数据副本是一致的，强调数据的一致性。这种原子性可以理解为” 硬状态 “。</p>\n<p>软状态则允许系统中的数据存在中间状态，并认为该状态不影响系统的整体可用性，即允许系统在不同节点的数据副本上存在数据延时。</p>\n<h3 id=\"最终一致性\"><a class=\"markdownIt-Anchor\" href=\"#最终一致性\">#</a> 最终一致性</h3>\n<p>数据不可能一直处于软状态，必须在一个时间期限后达到各个节点的一致性。在期限过后，应当保证所有副本中的数据保持一致性，也就是达到了数据的最终一致性。</p>\n<p>在系统设计中，最终一致性实现的时间取决于网络延时、系统负载、不同的存储选型，不同数据复制方案设计等因素。也就是说，谁都不保证用户什么时候能看到更新好的数据，但是总会看到的。</p>\n<p>最终一致性作为弱一致性中的特例，强调的是所有数据副本，在经过一段时间的同步后，最终能够到达一致的状态，不需要实时保证系统数据的强一致性，而到达最终一致性。</p>\n<p>根据业务需求的不同，最终一致性中又有很多种情况：</p>\n<ul>\n<li>\n<p>因果一致性：要求有因果关系的操作顺序得到保证，非因果关系的操作顺序则无所谓。例如微信朋友圈的评论以及对评论的答复所构成的因果关系。</p>\n</li>\n<li>\n<ul>\n<li>会话一致性：在操作顺序得到保证的前提下，保证用户在同一个会话里读取数据时保证数据是最新的，如分布式系统 Session 一致性解决方案。</li>\n</ul>\n</li>\n<li>\n<p>单调读一致性：用户读取某个数据值后，其后续操作不会读取到该数据更早版本的值。</p>\n</li>\n<li>\n<p>单调写一致性：要求数据的所有副本，以相同的顺序执行所有的更新操作，也称为时间轴一致性。</p>\n</li>\n</ul>\n<p><img src=\"/images/v2-3d4420b4d4eb057f590da858ba6c7523_r.jpg\" alt=\"img\"></p>\n<hr>\n<h2 id=\"两阶段提交2pc\"><a class=\"markdownIt-Anchor\" href=\"#两阶段提交2pc\">#</a> 两阶段提交（2PC）</h2>\n<p>在分布式系统中，为了让每个节点都能够感知到其他节点的事务执行状况，需要引入一个中心节点来统一处理所有节点的执行逻辑，这个中心节点叫做协调者（coordinator），被中心节点调度的其他业务节点叫做参与者（participant）。</p>\n<p>2PC 将分布式事务分成了两个阶段，两个阶段分别为提交请求（投票）和提交（执行）。协调者根据参与者的响应来决定是否需要真正地执行事务。具体步骤如下：</p>\n<h3 id=\"提交请求投票阶段\"><a class=\"markdownIt-Anchor\" href=\"#提交请求投票阶段\">#</a> 提交请求（投票）阶段</h3>\n<ul>\n<li>协调者向所有参与者发送 prepare 请求与事务内容，询问是否可以准备事务提交，并等待参与者的响应。</li>\n<li>参与者执行事务中包含的操作，并记录 undo 日志（用于回滚）和 redo 日志（用于重放），但不真正提交。</li>\n<li>参与者向协调者返回事务操作的执行结果，执行成功返回 yes，否则返回 no。</li>\n</ul>\n<h3 id=\"提交执行阶段\"><a class=\"markdownIt-Anchor\" href=\"#提交执行阶段\">#</a> 提交（执行）阶段</h3>\n<p>分为成功和失败两种情况：</p>\n<p>若所有参与者都返回 yes，说明事务可以提交：</p>\n<ul>\n<li>协调者向所有参与者发送提交（commit）请求。</li>\n<li>参与者收到提交（commit）请求后，将事务真正地提交上去，并释放占用的事务资源，并向协调者返回 ack。</li>\n<li>协调者收到所有参与者的 ack 消息，事务成功完成。</li>\n</ul>\n<p>若有参与者返回 no 或者超时未返回，说明事务中断，需要回滚：</p>\n<ul>\n<li>协调者向所有参与者发送 rollback 请求。</li>\n<li>参与者收到 rollback 请求后，根据 undo 日志回滚到事务执行前的状态，释放占用的事务资源，并向协调者返回 ack。</li>\n<li>协调者收到所有参与者的 ack 消息，事务回滚完成。</li>\n</ul>\n<h3 id=\"2pc的缺点\"><a class=\"markdownIt-Anchor\" href=\"#2pc的缺点\">#</a> 2PC 的缺点</h3>\n<p>1、协调者存在单点问题。如果协调者挂了，整个 2PC 逻辑就彻底不能运行。</p>\n<p>2、执行过程是完全同步的。各参与者在等待其他参与者响应的过程中都处于阻塞状态，大并发下有性能问题。</p>\n<p>3、仍然存在不一致风险。如果由于网络异常等意外导致只有部分参与者收到了 commit 请求，就会造成部分参与者提交了事务而其他参与者未提交的情况。</p>\n<hr>\n<h2 id=\"三阶段提交3pc\"><a class=\"markdownIt-Anchor\" href=\"#三阶段提交3pc\">#</a> 三阶段提交（3PC）</h2>\n<h3 id=\"cancommit-阶段\"><a class=\"markdownIt-Anchor\" href=\"#cancommit-阶段\">#</a> CanCommit 阶段</h3>\n<p>类似于 2PC 的准备（第一）阶段。协调者向参与者发送 commit 请求，参与者如果可以提交就返回 Yes 响应，否则返回 No 响应。</p>\n<ul>\n<li>事务询问： 协调者向参与者发送 CanCommit 请求，询问是否可以执行事务提交操作，然后开始等待参与者的响应。</li>\n<li>响应反馈： 参与者接到 CanCommit 请求之后，正常情况下， 如果其自身认为可以顺利执行事务，则返回 Yes 响应，并进入预备状态， 否则返回 No。</li>\n</ul>\n<h3 id=\"precommit-阶段\"><a class=\"markdownIt-Anchor\" href=\"#precommit-阶段\">#</a> PreCommit 阶段</h3>\n<p>协调者根据参与者的反应情况来决定是否可以执行事务的 PreCommit 操作，根据响应情况，有以下两种可能：</p>\n<p>如果响应 Yes，则：</p>\n<ul>\n<li>发送预提交请求：协调者向参与者发送 PreCommit 请求，并进入 Prepared 阶段。</li>\n<li>事务预提交：参与者接收到 PreCommit 请求后，会执行事务操作，并将 undo 和 redo 信息记录到事务日志中。</li>\n<li>响应反馈：如果参与者成功的执行事务操作，则返回 ack 响应，同时开始等待最终指令。</li>\n</ul>\n<p>假如有任何一个参与者向协调者发送 No 响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断。则：</p>\n<ul>\n<li>发送中断请求：协调者向所有参与者发送 abort 请求。</li>\n<li>中断事务：参与者收到来自协调者的 abort 请求之后（或超时之后，仍未收到协调者的请求），执行事务的中断。</li>\n</ul>\n<h3 id=\"docommit-阶段\"><a class=\"markdownIt-Anchor\" href=\"#docommit-阶段\">#</a> doCommit 阶段</h3>\n<p>该阶段进行真正的事务提交，也可以分为执行提交和中断事务两种情况。</p>\n<p>如果执行成功，则有如下操作：</p>\n<ul>\n<li>\n<p>发送提交请求</p>\n<p>协调者接收到参与者发送的 ack 响应，那么它将从预提交状态进入到提交状态，并向所有参与者发送 doCommit 请求。</p>\n</li>\n<li>\n<p>事务提交</p>\n<p>参与者接收到 doCommit 请求之后，执行正式的事务提交，并在完成事务提交之后释放所有事务资源。</p>\n</li>\n<li>\n<p>响应反馈</p>\n<p>事务提交完之后，向协调者发送 ack 响应。</p>\n</li>\n<li>\n<p>完成事务</p>\n<p>协调者接收到所有参与者的 ack 响应之后，完成事务。</p>\n</li>\n</ul>\n<p>协调者没有接收到参与者发送的 ACK 响应（可能是接受者发送的不是 ACK 响应，也可能响应超时），那么就会执行中断事务。则有如下操作：</p>\n<ul>\n<li>\n<p>发送中断请求</p>\n<p>协调者向所有参与者发送 abort 请求</p>\n</li>\n<li>\n<p>事务回滚</p>\n<p>参与者接收到 abort 请求之后，利用其在阶段二记录的 undo 信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源。</p>\n</li>\n<li>\n<p>反馈结果</p>\n<p>参与者完成事务回滚之后，向协调者发送 ACK 消息</p>\n</li>\n<li>\n<p>中断事务</p>\n<p>协调者接收到参与者反馈的 ACK 消息之后，执行事务的中断。</p>\n</li>\n</ul>\n<h3 id=\"3pc的缺点\"><a class=\"markdownIt-Anchor\" href=\"#3pc的缺点\">#</a> 3PC 的缺点</h3>\n<p>相对于 2PC，3PC 主要解决的单点故障问题，并减少阻塞，因为一旦参与者无法及时收到来自协调者的信息之后，他会默认执行 commit，而不会一直持有事务资源并处于阻塞状态。但是这种机制也会导致数据一致性问题，因为，由于网络原因，协调者发送的 abort 响应没有及时被参与者接收到，那么参与者在等待超时之后执行了 commit 操作，这样就和其他接到 abort 命令并执行回滚的参与者之间存在数据不一致的情况。</p>\n<hr>\n",
            "tags": [
                "论文",
                "分布式"
            ]
        }
    ]
}