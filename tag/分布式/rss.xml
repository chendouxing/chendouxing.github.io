<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>蟹堡王海星 • Posts by &#34;分布式&#34; tag</title>
        <link>https://chendouxing.github.io</link>
        <description>花有重开日，人无再少年</description>
        <language>zh-CN</language>
        <pubDate>Wed, 06 Sep 2023 14:38:56 +0800</pubDate>
        <lastBuildDate>Wed, 06 Sep 2023 14:38:56 +0800</lastBuildDate>
        <category>源码</category>
        <category>SQL</category>
        <category>语言</category>
        <category>数学</category>
        <category>课堂学习</category>
        <category>计算机等级考试</category>
        <category>论文</category>
        <category>分布式</category>
        <item>
            <guid isPermalink="true">https://chendouxing.github.io/2023/09/06/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</guid>
            <title>分布式论文阅读</title>
            <link>https://chendouxing.github.io/2023/09/06/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</link>
            <category>论文</category>
            <category>分布式</category>
            <pubDate>Wed, 06 Sep 2023 14:38:56 +0800</pubDate>
            <description><![CDATA[ &lt;link rel=&#34;stylesheet&#34; class=&#34;aplayer-secondary-style-marker&#34; href=&#34;\assets\css\APlayer.min.css&#34;&gt;&lt;script src=&#34;\assets\js\APlayer.min.js&#34; class=&#34;aplayer-secondary-script-marker&#34;&gt;&lt;/script&gt;&lt;h1 id=&#34;分布式理论&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#分布式理论&#34;&gt;#&lt;/a&gt; 分布式理论&lt;/h1&gt;
&lt;h2 id=&#34;cap理论&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#cap理论&#34;&gt;#&lt;/a&gt; CAP 理论&lt;/h2&gt;
&lt;h3 id=&#34;理论概述&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#理论概述&#34;&gt;#&lt;/a&gt; 理论概述&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;一致性&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#一致性&#34;&gt;#&lt;/a&gt; 一致性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对于一致性，可以分为从客户端和服务端两个不同的视角。&lt;/p&gt;
&lt;p&gt;客户端：从客户端来看，一致性主要指的是多并发访问时更新过的数据如何获取的问题。&lt;/p&gt;
&lt;p&gt;服务端：从服务端来看，则是更新如何分布到整个系统，以保证数据最终一致。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于一致性，可以分为强 / 弱 / 最终一致性三类&lt;/p&gt;
&lt;p&gt;从客户端角度，多进程并发访问时，更新过的数据在不同进程如何获取的不同策略，决定了不同的一致性。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;强一致性：对于关系型数据库，要求更新过的数据能被后续的访问都能看到，这是强一致性。&lt;/li&gt;
&lt;li&gt;弱一致性：如果能容忍后续的部分或者全部访问不到，则是弱一致性。&lt;/li&gt;
&lt;li&gt;最终一致性：如果经过一段时间后要求能访问到更新后的数据，则是最终一致性。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;可用性&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#可用性&#34;&gt;#&lt;/a&gt; 可用性&lt;/h3&gt;
&lt;p&gt;可用性指服务在正常响应时间内一直可用。&lt;/p&gt;
&lt;p&gt;好的可用性主要是指系统能够很好的为用户服务，不出现用户操作失败或者访问超时等用户体验不好的情况。可用性通常情况下与分布式数据冗余，负载均衡等有着很大的关联。&lt;/p&gt;
&lt;h3 id=&#34;分区容错性&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#分区容错性&#34;&gt;#&lt;/a&gt; 分区容错性&lt;/h3&gt;
&lt;p&gt;分区容错性指分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性或可用性的服务。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;base模型&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#base模型&#34;&gt;#&lt;/a&gt; BASE 模型&lt;/h2&gt;
&lt;h3 id=&#34;理论概述-2&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#理论概述-2&#34;&gt;#&lt;/a&gt; 理论概述&lt;/h3&gt;
&lt;p&gt;Base 理论是三要素的缩写：基本可用（Basically Available）、软状态（Soft-state）、最终一致性（Eventually Consistency）。&lt;/p&gt;
&lt;h3 id=&#34;基本可用&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#基本可用&#34;&gt;#&lt;/a&gt; 基本可用&lt;/h3&gt;
&lt;p&gt;“基本可用” 要求系统能够基本运行，一直提供服务，强调的是分布式系统在出现不可预知故障的时候，允许损失部分可用性。&lt;/p&gt;
&lt;h3 id=&#34;软状态&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#软状态&#34;&gt;#&lt;/a&gt; 软状态&lt;/h3&gt;
&lt;p&gt;相对于 ACID 事务中原子性要求（要么做，要么不做），强调的是强制一致性，要求多个节点的数据副本是一致的，强调数据的一致性。这种原子性可以理解为” 硬状态 “。&lt;/p&gt;
&lt;p&gt;软状态则允许系统中的数据存在中间状态，并认为该状态不影响系统的整体可用性，即允许系统在不同节点的数据副本上存在数据延时。&lt;/p&gt;
&lt;h3 id=&#34;最终一致性&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#最终一致性&#34;&gt;#&lt;/a&gt; 最终一致性&lt;/h3&gt;
&lt;p&gt;数据不可能一直处于软状态，必须在一个时间期限后达到各个节点的一致性。在期限过后，应当保证所有副本中的数据保持一致性，也就是达到了数据的最终一致性。&lt;/p&gt;
&lt;p&gt;在系统设计中，最终一致性实现的时间取决于网络延时、系统负载、不同的存储选型，不同数据复制方案设计等因素。也就是说，谁都不保证用户什么时候能看到更新好的数据，但是总会看到的。&lt;/p&gt;
&lt;p&gt;最终一致性作为弱一致性中的特例，强调的是所有数据副本，在经过一段时间的同步后，最终能够到达一致的状态，不需要实时保证系统数据的强一致性，而到达最终一致性。&lt;/p&gt;
&lt;p&gt;根据业务需求的不同，最终一致性中又有很多种情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;因果一致性：要求有因果关系的操作顺序得到保证，非因果关系的操作顺序则无所谓。例如微信朋友圈的评论以及对评论的答复所构成的因果关系。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;会话一致性：在操作顺序得到保证的前提下，保证用户在同一个会话里读取数据时保证数据是最新的，如分布式系统 Session 一致性解决方案。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;单调读一致性：用户读取某个数据值后，其后续操作不会读取到该数据更早版本的值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;单调写一致性：要求数据的所有副本，以相同的顺序执行所有的更新操作，也称为时间轴一致性。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/images/v2-3d4420b4d4eb057f590da858ba6c7523_r.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;两阶段提交2pc&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#两阶段提交2pc&#34;&gt;#&lt;/a&gt; 两阶段提交（2PC）&lt;/h2&gt;
&lt;p&gt;在分布式系统中，为了让每个节点都能够感知到其他节点的事务执行状况，需要引入一个中心节点来统一处理所有节点的执行逻辑，这个中心节点叫做协调者（coordinator），被中心节点调度的其他业务节点叫做参与者（participant）。&lt;/p&gt;
&lt;p&gt;2PC 将分布式事务分成了两个阶段，两个阶段分别为提交请求（投票）和提交（执行）。协调者根据参与者的响应来决定是否需要真正地执行事务。具体步骤如下：&lt;/p&gt;
&lt;h3 id=&#34;提交请求投票阶段&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#提交请求投票阶段&#34;&gt;#&lt;/a&gt; 提交请求（投票）阶段&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;协调者向所有参与者发送 prepare 请求与事务内容，询问是否可以准备事务提交，并等待参与者的响应。&lt;/li&gt;
&lt;li&gt;参与者执行事务中包含的操作，并记录 undo 日志（用于回滚）和 redo 日志（用于重放），但不真正提交。&lt;/li&gt;
&lt;li&gt;参与者向协调者返回事务操作的执行结果，执行成功返回 yes，否则返回 no。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;提交执行阶段&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#提交执行阶段&#34;&gt;#&lt;/a&gt; 提交（执行）阶段&lt;/h3&gt;
&lt;p&gt;分为成功和失败两种情况：&lt;/p&gt;
&lt;p&gt;若所有参与者都返回 yes，说明事务可以提交：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;协调者向所有参与者发送提交（commit）请求。&lt;/li&gt;
&lt;li&gt;参与者收到提交（commit）请求后，将事务真正地提交上去，并释放占用的事务资源，并向协调者返回 ack。&lt;/li&gt;
&lt;li&gt;协调者收到所有参与者的 ack 消息，事务成功完成。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;若有参与者返回 no 或者超时未返回，说明事务中断，需要回滚：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;协调者向所有参与者发送 rollback 请求。&lt;/li&gt;
&lt;li&gt;参与者收到 rollback 请求后，根据 undo 日志回滚到事务执行前的状态，释放占用的事务资源，并向协调者返回 ack。&lt;/li&gt;
&lt;li&gt;协调者收到所有参与者的 ack 消息，事务回滚完成。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2pc的缺点&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#2pc的缺点&#34;&gt;#&lt;/a&gt; 2PC 的缺点&lt;/h3&gt;
&lt;p&gt;1、协调者存在单点问题。如果协调者挂了，整个 2PC 逻辑就彻底不能运行。&lt;/p&gt;
&lt;p&gt;2、执行过程是完全同步的。各参与者在等待其他参与者响应的过程中都处于阻塞状态，大并发下有性能问题。&lt;/p&gt;
&lt;p&gt;3、仍然存在不一致风险。如果由于网络异常等意外导致只有部分参与者收到了 commit 请求，就会造成部分参与者提交了事务而其他参与者未提交的情况。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;三阶段提交3pc&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#三阶段提交3pc&#34;&gt;#&lt;/a&gt; 三阶段提交（3PC）&lt;/h2&gt;
&lt;h3 id=&#34;cancommit-阶段&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#cancommit-阶段&#34;&gt;#&lt;/a&gt; CanCommit 阶段&lt;/h3&gt;
&lt;p&gt;类似于 2PC 的准备（第一）阶段。协调者向参与者发送 commit 请求，参与者如果可以提交就返回 Yes 响应，否则返回 No 响应。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事务询问： 协调者向参与者发送 CanCommit 请求，询问是否可以执行事务提交操作，然后开始等待参与者的响应。&lt;/li&gt;
&lt;li&gt;响应反馈： 参与者接到 CanCommit 请求之后，正常情况下， 如果其自身认为可以顺利执行事务，则返回 Yes 响应，并进入预备状态， 否则返回 No。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;precommit-阶段&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#precommit-阶段&#34;&gt;#&lt;/a&gt; PreCommit 阶段&lt;/h3&gt;
&lt;p&gt;协调者根据参与者的反应情况来决定是否可以执行事务的 PreCommit 操作，根据响应情况，有以下两种可能：&lt;/p&gt;
&lt;p&gt;如果响应 Yes，则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发送预提交请求：协调者向参与者发送 PreCommit 请求，并进入 Prepared 阶段。&lt;/li&gt;
&lt;li&gt;事务预提交：参与者接收到 PreCommit 请求后，会执行事务操作，并将 undo 和 redo 信息记录到事务日志中。&lt;/li&gt;
&lt;li&gt;响应反馈：如果参与者成功的执行事务操作，则返回 ack 响应，同时开始等待最终指令。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;假如有任何一个参与者向协调者发送 No 响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断。则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发送中断请求：协调者向所有参与者发送 abort 请求。&lt;/li&gt;
&lt;li&gt;中断事务：参与者收到来自协调者的 abort 请求之后（或超时之后，仍未收到协调者的请求），执行事务的中断。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;docommit-阶段&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#docommit-阶段&#34;&gt;#&lt;/a&gt; doCommit 阶段&lt;/h3&gt;
&lt;p&gt;该阶段进行真正的事务提交，也可以分为执行提交和中断事务两种情况。&lt;/p&gt;
&lt;p&gt;如果执行成功，则有如下操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;发送提交请求&lt;/p&gt;
&lt;p&gt;协调者接收到参与者发送的 ack 响应，那么它将从预提交状态进入到提交状态，并向所有参与者发送 doCommit 请求。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;事务提交&lt;/p&gt;
&lt;p&gt;参与者接收到 doCommit 请求之后，执行正式的事务提交，并在完成事务提交之后释放所有事务资源。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;响应反馈&lt;/p&gt;
&lt;p&gt;事务提交完之后，向协调者发送 ack 响应。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;完成事务&lt;/p&gt;
&lt;p&gt;协调者接收到所有参与者的 ack 响应之后，完成事务。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;协调者没有接收到参与者发送的 ACK 响应（可能是接受者发送的不是 ACK 响应，也可能响应超时），那么就会执行中断事务。则有如下操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;发送中断请求&lt;/p&gt;
&lt;p&gt;协调者向所有参与者发送 abort 请求&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;事务回滚&lt;/p&gt;
&lt;p&gt;参与者接收到 abort 请求之后，利用其在阶段二记录的 undo 信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;反馈结果&lt;/p&gt;
&lt;p&gt;参与者完成事务回滚之后，向协调者发送 ACK 消息&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;中断事务&lt;/p&gt;
&lt;p&gt;协调者接收到参与者反馈的 ACK 消息之后，执行事务的中断。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3pc的缺点&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#3pc的缺点&#34;&gt;#&lt;/a&gt; 3PC 的缺点&lt;/h3&gt;
&lt;p&gt;相对于 2PC，3PC 主要解决的单点故障问题，并减少阻塞，因为一旦参与者无法及时收到来自协调者的信息之后，他会默认执行 commit，而不会一直持有事务资源并处于阻塞状态。但是这种机制也会导致数据一致性问题，因为，由于网络原因，协调者发送的 abort 响应没有及时被参与者接收到，那么参与者在等待超时之后执行了 commit 操作，这样就和其他接到 abort 命令并执行回滚的参与者之间存在数据不一致的情况。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;多版本并发控制mvcc原理&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#多版本并发控制mvcc原理&#34;&gt;#&lt;/a&gt; 多版本并发控制（MVCC）原理&lt;/h2&gt;
&lt;p&gt;参考&lt;a href=&#34;https://juejin.cn/post/7016165148020703246&#34;&gt;看一遍就理解：MVCC 原理详解 - 掘金 (juejin.cn)&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;事务并发存在的问题&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#事务并发存在的问题&#34;&gt;#&lt;/a&gt; 事务并发存在的问题&lt;/h3&gt;
&lt;p&gt;事务并发会引起&lt;strong&gt;脏读、不可重复读、幻读&lt;/strong&gt;问题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;脏读：如果一个事务读取到了另一个事务未提交修改过的数据，称发生了&lt;strong&gt;脏读&lt;/strong&gt;现象。&lt;/li&gt;
&lt;li&gt;不可重复读：同一个事务内，前后多次读取，读取到的数据内容不一致。在事务 A 范围内，两个相同的查询，读取同一条记录，却返回了不同的数据，这称为&lt;strong&gt;不可重复读&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;幻读：如果一个事务先根据某些搜索条件查询出一些记录，在该事务未提交时，另一个事务写入了一些符合那些搜索条件的记录（如 insert、delete、update），就意味着发生了&lt;strong&gt;幻读&lt;/strong&gt;。事务 A 查询一个范围的结果集，另一个并发事务 B 往这个范围中插入新的数据，并提交事务，然后事务 A 再次查询相同的范围，两次读取到的结果集却不一样了，这就是&lt;strong&gt;幻读&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;四大隔离级别&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#四大隔离级别&#34;&gt;#&lt;/a&gt; 四大隔离级别&lt;/h3&gt;
&lt;p&gt;为了解决并发事务存在的&lt;strong&gt;脏读、不可重复读、幻读&lt;/strong&gt;等问题，数据库设计了四种隔离级别，分别是&lt;strong&gt;读未提交，读已提交，可重复读，串行化（Serializable）&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;读未提交&lt;/p&gt;
&lt;p&gt;读未提交隔离级别，只限制了两个数据&lt;strong&gt;不能同时修改&lt;/strong&gt;，但是修改数据的时候，即使事务未提交，都是可以被别的事务读取到的，这级别的事务隔离有脏读、重复读、幻读的问题；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;读已提交&lt;/p&gt;
&lt;p&gt;读已提交隔离级别，当前事务只能读取到其他事务&lt;strong&gt;提交&lt;/strong&gt;的数据，所以这种事务的隔离级别&lt;strong&gt;解决了脏读&lt;/strong&gt;问题，但还是会存在&lt;strong&gt;重复读、幻读&lt;/strong&gt;问题；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可重复读&lt;/p&gt;
&lt;p&gt;可重复读隔离级别，限制了读取数据的时候，不可以进行修改，所以&lt;strong&gt;解决了重复读&lt;/strong&gt;的问题，但是读取范围数据的时候，是可以插入数据，所以还会存在&lt;strong&gt;幻读&lt;/strong&gt;问题；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可串行化&lt;/p&gt;
&lt;p&gt;事务最高的隔离级别，在该级别下，所有事务都是进行&lt;strong&gt;串行化顺序&lt;/strong&gt;执行的。可以避免脏读、不可重复读与幻读所有并发问题。但是这种事务隔离级别下，事务执行很耗性能。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/images/image-20230907185451838.png&#34; alt=&#34;image-20230907185451838&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;mvcc概述&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#mvcc概述&#34;&gt;#&lt;/a&gt; MVCC 概述&lt;/h3&gt;
&lt;p&gt;通俗的说，数据库中同时存在多个版本的数据，并不是整个数据库的多个版本，而是某一条记录的多个版本同时存在，在某个事务对其进行操作的时候，需要查看这一条记录的隐藏列事务版本 id，比对事务 id 并根据事物隔离级别去判断读取哪个版本的数据。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;事务版本号&lt;/p&gt;
&lt;p&gt;事务每次开启前，都会从数据库获得一个&lt;strong&gt;自增长&lt;/strong&gt;的事务 ID，可以从事务 ID 判断事务的执行先后顺序，这就是事务版本号。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;隐式字段&lt;/p&gt;
&lt;p&gt;对于 InnoDB 存储引擎，每一行记录都有两个隐藏列&lt;strong&gt; trx_id&lt;/strong&gt;、&lt;strong&gt;roll_pointer&lt;/strong&gt;，如果表中没有主键和非 NULL 唯一键时，则还会有第三个隐藏的主键列&lt;strong&gt; row_id&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/image-20230907190609258.png&#34; alt=&#34;image-20230907190609258&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;undo log&lt;/p&gt;
&lt;p&gt;undo log，&lt;strong&gt;回滚日志&lt;/strong&gt;，用于记录数据被修改前的信息。在表记录修改之前，会先把数据拷贝到 undo log 里，如果事务回滚，即可以通过 undo log 来还原数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;版本链&lt;/p&gt;
&lt;p&gt;多个事务并行操作某一行数据时，不同事务对该行数据的修改会产生多个版本，然后通过回滚指针（roll_pointer），连成一个链表，这个链表就称为&lt;strong&gt;版本链&lt;/strong&gt;。通过版本链，我们就可以看出&lt;strong&gt;事务版本号、表格隐藏的列和 undo log&lt;/strong&gt; 它们之间的关系。如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/69abb7c89d1e4d9f8e242d9e0a410e3e~tplv-k3u1fbpfcp-zoom-i&#34; alt=&#34;版本链&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;快照读和当前读&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;快照读：&lt;/strong&gt; 读取的是记录数据的可见版本（有旧的版本）。不加锁，普通的 select 语句都是快照读。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当前读&lt;/strong&gt;：读取的是记录数据的最新版本，显式加锁的都是当前读。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Read View&lt;/p&gt;
&lt;p&gt;事务执行 SQL 语句时，产生的读视图。实际上在 innodb 中，每个 SQL 语句执行前都会得到一个 Read View。它主要是用来做可见性判断的，即判断当前事务可见哪个版本的数据。&lt;/p&gt;
&lt;p&gt;相关参数：&lt;/p&gt;
&lt;p&gt;m_ids：当前系统中那些活跃 (未提交) 的读写事务 ID, 它数据结构为一个 List。&lt;/p&gt;
&lt;p&gt;min_limit_id：表示在生成 ReadView 时，当前系统中活跃的读写事务中最小的事务 id，即 m_ids 中的最小值。&lt;/p&gt;
&lt;p&gt;max_limit_id：表示生成 ReadView 时，系统中应该分配给下一个事务的 id 值。&lt;/p&gt;
&lt;p&gt;creator_trx_id：创建当前 read view 的事务 ID&lt;/p&gt;
&lt;p&gt;Read View 匹配规则：&lt;/p&gt;
&lt;p&gt;1、如果数据事务 ID  &lt;code&gt;trx_id &amp;lt; min_limit_id&lt;/code&gt; ，表明生成该版本的事务在生成 Read View 前，已经提交 (因为事务 ID 是递增的)，所以该版本可以被当前事务访问。&lt;/p&gt;
&lt;p&gt;2、如果 &lt;code&gt;trx_id&amp;gt;= max_limit_id&lt;/code&gt; ，表明生成该版本的事务在生成 ReadView 后才生成，所以该版本不可以被当前事务访问。&lt;/p&gt;
&lt;p&gt;3、如果  &lt;code&gt;min_limit_id =&amp;lt;trx_id&amp;lt; max_limit_id&lt;/code&gt; ，需要分 3 种情况讨论：&lt;/p&gt;
&lt;p&gt;（1）如果 &lt;code&gt;m_ids&lt;/code&gt;  包含 &lt;code&gt;trx_id&lt;/code&gt; , 则代表 Read View 生成时刻，这个事务还未提交，但是如果数据的 &lt;code&gt;trx_id&lt;/code&gt;  等于 &lt;code&gt;creator_trx_id&lt;/code&gt;  的话，表明数据是自己生成的，因此是&lt;strong&gt;可见&lt;/strong&gt;的。&lt;/p&gt;
&lt;p&gt;（2）如果 &lt;code&gt;m_ids&lt;/code&gt;  包含 &lt;code&gt;trx_id&lt;/code&gt; ，并且 &lt;code&gt;trx_id&lt;/code&gt;  不等于 &lt;code&gt;creator_trx_id&lt;/code&gt; ，则 Read   View 生成时，事务未提交，并且不是自己生产的，所以当前事务也是&lt;strong&gt;看不见&lt;/strong&gt;的；&lt;/p&gt;
&lt;p&gt;（3）如果 &lt;code&gt;m_ids&lt;/code&gt;  不包含 &lt;code&gt;trx_id&lt;/code&gt; ，则说明你这个事务在 Read View 生成之前就已经提交了，修改的结果，当前事务是能看见的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;mvcc实现原理&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#mvcc实现原理&#34;&gt;#&lt;/a&gt; MVCC 实现原理&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;基于 MVCC 查询一条记录&lt;/p&gt;
&lt;p&gt;1、获取事务自己的版本号，即事务 ID；&lt;/p&gt;
&lt;p&gt;2、获取 Read View；&lt;/p&gt;
&lt;p&gt;3、查询得到的数据，然后 Read View 中的事务版本号进行比较；&lt;/p&gt;
&lt;p&gt;4、如果不符合 Read View 的可见性规则， 即就需要 Undo log 中历史快照；&lt;/p&gt;
&lt;p&gt;5、最后返回符合规则的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;InnoDB 实现 MVCC，是通过 &lt;code&gt; Read View+ Undo Log&lt;/code&gt;  实现的，Undo Log 保存了历史快照，Read View 可见性规则帮助判断当前版本的数据是否可见。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;读已提交（RC）隔离级别，存在不可重复读问题&lt;/p&gt;
&lt;p&gt;在&lt;strong&gt;读已提交（RC）隔离级别&lt;/strong&gt;下，同一个事务里，两个相同的查询，读取同一条记录（id=1），却返回了不同的数据（&lt;strong&gt;第一次查出来是孙权，第二次查出来是曹操那条记录&lt;/strong&gt;），因此 RC 隔离级别，存在&lt;strong&gt;不可重复读&lt;/strong&gt;并发问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可重复读（RR）隔离级别，解决不可重复读问题&lt;/p&gt;
&lt;p&gt;RR 可以解决不可重复读问题，就是跟 Read view 工作方式有关。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在读已提交（RC）隔离级别下，同一个事务里面，&lt;strong&gt;每一次查询都会产生一个新的 Read View 副本&lt;/strong&gt;，这样就可能造成同一个事务里前后读取数据可能不一致的问题（不可重复读并发问题）。&lt;/li&gt;
&lt;li&gt;在可重复读（RR）隔离级别下，&lt;strong&gt;一个事务里只会获取一次 read view&lt;/strong&gt;，都是副本共用的，从而保证每次查询的数据都是一样的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
 ]]></description>
        </item>
    </channel>
</rss>
